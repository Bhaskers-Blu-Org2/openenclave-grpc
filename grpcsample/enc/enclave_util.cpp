// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include <stdio.h>

// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "helloworld_t.h"
//#include "hello.pb.h"
#include <iostream>
#include <memory>
#include <string>


#include <grpcpp/grpcpp.h>

#include "helloworld.grpc.pb.h"
using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using helloworld::HelloRequest;
using helloworld::HelloReply;
using helloworld::Greeter;

#include <cstdlib>
#include <cstring>
#include <functional>
#include <map>
#include <thread>
#include <vector>
#include <atomic>


#ifndef _OE_INTERNAL_PTHREADHOOKS_H
#define _OE_INTERNAL_PTHREADHOOKS_H

#include <openenclave/bits/defs.h>
#include <openenclave/bits/result.h>
#include <pthread.h>

#ifndef _THREAD_ARGS_H
#define _THREAD_ARGS_H

#include <atomic>
#include <mutex>

const uint64_t MAX_ENC_KEYS = 16;

class atomic_flag_lock
{
public:
    void lock()
    {
        while (_flag.test_and_set())
        {
            continue;
        }
    }
    void unlock()
    {
        _flag.clear();
    }

private:
    std::atomic_flag _flag = ATOMIC_FLAG_INIT;
};

typedef std::unique_lock<atomic_flag_lock> atomic_lock;

#endif /* _THREAD_ARGS_H */

OE_EXTERNC_BEGIN
typedef struct _oe_pthread_hooks
{
    int(*create)(
        pthread_t* thread,
        const pthread_attr_t* attr,
        void* (*start_routine)(void*),
        void* arg);

    int(*join)(pthread_t thread, void** retval);

    int(*detach)(pthread_t thread);
    int(*cond_timedwait)(pthread_cond_t * cond,
        pthread_mutex_t *mutex,
        const struct timespec *abstime);
} oe_pthread_hooks_t;

void oe_register_pthread_hooks(oe_pthread_hooks_t* pthread_hooks);

OE_EXTERNC_END

#endif /* _OE_INTERNAL_PTHREADHOOKS_H */

static std::vector<std::function<void*()>> _thread_functions;
static uint64_t _next_enc_thread_id = 0;
static uint64_t _enc_key = 0; // Monotonically increasing enclave key

// Map of enc_key to thread_id returned by pthread_self()
static std::map<uint64_t, pthread_t> _key_to_thread_id_map;

static atomic_flag_lock _enc_lock;

struct thread_args
{
    uint64_t enc_key;
    int join_ret;
    int detach_ret;
};
// Each new thread will point to memory created by the host after thread
// creation
thread_args _thread_args[MAX_ENC_KEYS];

static int _pthread_create_hook(
    pthread_t* enc_thread,
    const pthread_attr_t*,
    void* (*start_routine)(void*),
    void* arg)
{
    *enc_thread = 0;
    uint64_t enc_key;
    {
        atomic_lock lock(_enc_lock);
        _thread_functions.push_back(
            [start_routine, arg]() { return start_routine(arg); });
        enc_key = _enc_key = ++_next_enc_thread_id;
        printf("_pthread_create_hook(): enc_key is %lu\n", enc_key);
        // Populate the enclave key to thread id map in advance
        _key_to_thread_id_map.insert(std::make_pair(enc_key, *enc_thread));

        if (_next_enc_thread_id > (MAX_ENC_KEYS - 1))
        {
            printf(
                "Exceeded max number of enclave threads supported %lu\n",
                MAX_ENC_KEYS - 1);
        }
    }

    // Send the enclave id so that host can maintain the map between
    // enclave and host id
    if (OE_OK != host_create_thread(enc_key, oe_get_enclave()))
    {
        printf(
            "_pthread_create_hook(): Error in call to host_create_pthread "
            "for enc_key=%lu\n",
            enc_key);
        oe_abort();
    }

    // Block until the enclave pthread_id becomes available in the map
    while (*enc_thread == 0)
    {
        {
            atomic_lock lock(_enc_lock);
            *enc_thread = _key_to_thread_id_map[enc_key];
        }
        if (*enc_thread == 0)
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
        }
    }

    printf(
        "_pthread_create_hook(): pthread_create success for enc_key=%lu; "
        "thread id=%#10lx\n",
        _enc_key,
        *enc_thread);

    return 0;
}

static int _pthread_cond_timedwait(pthread_cond_t * cond,
    pthread_mutex_t * mutex,
    const struct timespec * abstime)
{
    //int cond_timedwait_ret = 0;
    //printf("cond_timedwait called\n");
    /*if (host_cond_timedwait(&cond_timedwait_ret, cond, mutex, abstime) != OE_OK)
    {
        printf(
            "_pthread_cond_timedwait(): Error in call to host  host_pthread_cond_timedwait ");

        oe_abort();
    }*/
    return pthread_cond_wait(cond, mutex);

    // return cond_timedwait_ret;
}

static int _pthread_join_hook(pthread_t enc_thread, void**)
{
    // Find the enc_key from the enc_thread
    uint64_t join_enc_key;
    {
        atomic_lock lock(_enc_lock);
        std::map<uint64_t, pthread_t>::iterator it = std::find_if(
            _key_to_thread_id_map.begin(),
            _key_to_thread_id_map.end(),
            [&enc_thread](const std::pair<uint64_t, pthread_t>& p) {
            return p.second == enc_thread;
        });
        if (it == _key_to_thread_id_map.end())
        {
            printf(
                "_pthread_join_hook(): Error: enc_key for thread ID %#10lx not "
                "found\n",
                enc_thread);
            oe_abort();
        }

        join_enc_key = it->first;
        _thread_args[join_enc_key - 1].enc_key = join_enc_key;
    }

    printf(
        "_pthread_join_hook(): enc_key for thread ID %#10lx is %ld\n",
        enc_thread,
        join_enc_key);

    int join_ret = 0;
    if (host_join_thread(&join_ret, join_enc_key) != OE_OK)
    {
        printf(
            "_pthread_join_hook(): Error in call to host host_join_pthread for "
            "enc_key=%ld\n",
            join_enc_key);
        oe_abort();
    }

    {
        atomic_lock lock(_enc_lock);
        _thread_args[join_enc_key - 1].join_ret = join_ret;

        // Since join succeeded, delete the _key_to_thread_id_map
        if (!join_ret)
        {
            _key_to_thread_id_map.erase(join_enc_key);
        }
    }

    return join_ret;
}

static int _pthread_detach_hook(pthread_t enc_thread)
{
    // Find the enc_key from the enc_thread
    uint64_t det_enc_key;
    {
        atomic_lock lock(_enc_lock);
        std::map<uint64_t, pthread_t>::iterator it = std::find_if(
            _key_to_thread_id_map.begin(),
            _key_to_thread_id_map.end(),
            [&enc_thread](const std::pair<uint64_t, pthread_t>& p) {
            return p.second == enc_thread;
        });
        if (it == _key_to_thread_id_map.end())
        {
            printf(
                "_pthread_detach_hook(): Error: enc_key for thread ID %#10lx "
                "not found\n",
                enc_thread);
            oe_abort();
        }

        det_enc_key = it->first;
        _thread_args[det_enc_key - 1].enc_key = det_enc_key;
    }

    printf(
        "_pthread_detach_hook(): enc_key for thread ID %#10lx is %ld\n",
        enc_thread,
        det_enc_key);

    int det_ret = 0;
    if (host_detach_thread(&det_ret, det_enc_key) != OE_OK)
    {
        printf(
            "_pthread_detach_hook(): Error in call to host host_detach_thread "
            "for enc_key=%ld\n",
            det_enc_key);
        oe_abort();
    }

    // Since detach succeeded, delete the _key_to_thread_id_map
    if (0 == det_ret)
    {
        atomic_lock lock(_enc_lock);
        _key_to_thread_id_map.erase(det_enc_key);
    }

    return det_ret;
}

// Launches the new thread in the enclave
void enc_enclave_thread(uint64_t enc_key)
{
    _thread_args[_enc_key - 1].enc_key = enc_key;
    _thread_args[_enc_key - 1].join_ret = -1;
    _thread_args[_enc_key - 1].detach_ret = -1;

    std::function<void()> f;

    {
        atomic_lock lock(_enc_lock);
        _key_to_thread_id_map[enc_key] = pthread_self();
    }

    std::this_thread::yield();

    {
        atomic_lock lock(_enc_lock);
        f = _thread_functions.back();
        _thread_functions.pop_back();
    }
    f();
}

void  setuphooks()
{
    static oe_pthread_hooks_t _hooks = { .create = _pthread_create_hook,
                                        .join = _pthread_join_hook,
                                        .detach = _pthread_detach_hook,
                                        .cond_timedwait = _pthread_cond_timedwait };

    oe_register_pthread_hooks(&_hooks);
}


#ifdef __cplusplus
extern "C"
{
#endif
#include <poll.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <unistd.h>
#include <sys/eventfd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

    int pipe(int pipefd[2])
    {
        printf("***************pipe called\n");
        return 0;
    }
    int gethostname(char *name, size_t len)
    {
        printf("***************gethostname called\n");
        return 0;
    }
    ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
    {
        printf("***************writev called\n");
        return 0;
    }

    ssize_t recvfrom(int socket, void *__restrict buffer, size_t length,
        int flags, struct sockaddr *__restrict address,
        socklen_t *__restrict address_len)
    {
        printf("***************recvfrom called\n");
        return 0;
    }
    int poll(struct pollfd *fds, nfds_t nfds, int timeout)
    {
        printf("***************poll called\n");
        return 0;
    }


    ssize_t read(int fd, void *buf, size_t count)
    {
        printf("***************read called\n");
        return 0;
    }

    off_t lseek(int fd, off_t offset, int whence)
    {
        printf("***************lseek called\n");
        return 0;
    }

    ssize_t write(int fd, const void *buf, size_t count)
    {
        printf("***************wrie called\n");
        return 0;
    }


    int getifaddrs(struct ifaddrs **ifap)
    {
        printf("***************getifaddrs called\n");
        return 0;
    }

    void freeifaddrs(struct ifaddrs *ifa)
    {
        return;
    }
    int ioctl(int fd, unsigned long request, ...)
    {
        printf("***************ioctl called\n");
        return 0;
    }



#include <unistd.h>

    int unlink(const char *path)
    {
        return 0;
    }

    struct tm *localtime(const time_t *t)
    {
        static struct tm tm;
        //return localtime_r(t, &tm);
        return nullptr;
    }




#ifdef __cplusplus
}
#endif
