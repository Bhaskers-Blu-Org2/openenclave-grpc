/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "helloworld_t.h"
#include <openenclave/edger8r/enclave.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

OE_EXTERNC_BEGIN



/****** ECALL function wrappers  *************/
void ecall_ecall_run(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_run_args_t* pargs_in = (ecall_run_args_t*) input_buffer;
    ecall_run_args_t* pargs_out = (ecall_run_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* Check that in/in-out strings are null terminated */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_run(
        );

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_enc_enclave_thread(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    enc_enclave_thread_args_t* pargs_in = (enc_enclave_thread_args_t*) input_buffer;
    enc_enclave_thread_args_t* pargs_out = (enc_enclave_thread_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* Check that in/in-out strings are null terminated */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    enc_enclave_thread(
        pargs_in->enc_key);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}



/****** ECALL function table  *************/
oe_ecall_func_t __oe_ecalls_table[] = {
    (oe_ecall_func_t) ecall_ecall_run,
    (oe_ecall_func_t) ecall_enc_enclave_thread,
};

size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);


/* ocall wrappers */

oe_result_t oe_host_ocall_socket(
        oe_socket_result_t* _retval,
        int a,
        int b,
        int c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_socket_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_socket_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_socket_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_socket,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_socketpair(
        oe_socketpair_result_t* _retval,
        int a,
        int b,
        int c,
        int d[2])
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_socketpair_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;
    _args.d = (int*) d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_socketpair_args_t));
    if (d) OE_ADD_SIZE(_input_buffer_size, sizeof(int[2]));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_socketpair_args_t));
    if (d) OE_ADD_SIZE(_output_buffer_size, sizeof(int[2]));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(d, sizeof(int[2]));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_socketpair,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(d, (size_t)(sizeof(int[2])));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_bind(
        oe_bind_result_t* _retval,
        int a,
        const struct sockaddr* b,
        socklen_t c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_bind_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct sockaddr*) b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_bind_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_bind_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.c);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_bind,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getsockname(
        oe_getsockname_result_t* _retval,
        int a,
        struct sockaddr* b,
        socklen_t c_,
        socklen_t* c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getsockname_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct sockaddr*) b;
    _args.c_ = c_;
    _args.c = (socklen_t*) c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getsockname_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(socklen_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getsockname_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(socklen_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, _args.c_);
    OE_WRITE_IN_OUT_PARAM(c, sizeof(socklen_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getsockname,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(_args.c_));
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(socklen_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_connect(
        oe_connect_result_t* _retval,
        int a,
        const struct sockaddr* b,
        socklen_t c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_connect_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct sockaddr*) b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_connect_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_connect_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.c);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_connect,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getpeername(
        oe_getpeername_result_t* _retval,
        int a,
        struct sockaddr* b,
        socklen_t c_,
        socklen_t* c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getpeername_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct sockaddr*) b;
    _args.c_ = c_;
    _args.c = (socklen_t*) c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getpeername_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(socklen_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getpeername_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(socklen_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, _args.c_);
    OE_WRITE_IN_OUT_PARAM(c, sizeof(socklen_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getpeername,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(_args.c_));
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(socklen_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_send(
        oe_send_result_t* _retval,
        int a,
        const void* b,
        int c,
        int d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_send_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (void*) b;
    _args.c = c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_send_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_send_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.c);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_send,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_recv(
        oe_recv_result_t* _retval,
        int a,
        void* b,
        int c,
        int d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_recv_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (void*) b;
    _args.c = c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_recv_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_recv_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, _args.c);

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, _args.c);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_recv,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(_args.c));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_sendto(
        oe_sendto_result_t* _retval,
        int a,
        const void* b,
        int c,
        int d,
        const struct sockaddr* e,
        socklen_t f)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_sendto_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (void*) b;
    _args.c = c;
    _args.d = d;
    _args.e = (struct sockaddr*) e;
    _args.f = f;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_sendto_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_sendto_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.c);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_sendto,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_recvfrom(
        oe_recvfrom_result_t* _retval,
        int a,
        void* b,
        int c,
        int d,
        struct sockaddr* e,
        socklen_t f_,
        socklen_t* f)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_recvfrom_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (void*) b;
    _args.c = c;
    _args.d = d;
    _args.e = (struct sockaddr*) e;
    _args.f_ = f_;
    _args.f = (socklen_t*) f;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_recvfrom_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c);
    if (f) OE_ADD_SIZE(_input_buffer_size, sizeof(socklen_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_recvfrom_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, _args.c);
    if (f) OE_ADD_SIZE(_output_buffer_size, sizeof(socklen_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, _args.c);
    OE_WRITE_IN_OUT_PARAM(f, sizeof(socklen_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_recvfrom,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(_args.c));
    OE_READ_IN_OUT_PARAM(f, (size_t)(sizeof(socklen_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_sendmsg(
        oe_sendmsg_result_t* _retval,
        int a,
        struct msghdr* b,
        int c,
        void* msg_name,
        int msg_namelen,
        struct iovec* msg_iov,
        int msg_iovlen,
        void* msg_control,
        int msg_controllen,
        int msg_flags,
        void* iov_buffer,
        int total_iovlen)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_sendmsg_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct msghdr*) b;
    _args.c = c;
    _args.msg_name = (void*) msg_name;
    _args.msg_namelen = msg_namelen;
    _args.msg_iov = (struct iovec*) msg_iov;
    _args.msg_iovlen = msg_iovlen;
    _args.msg_control = (void*) msg_control;
    _args.msg_controllen = msg_controllen;
    _args.msg_flags = msg_flags;
    _args.iov_buffer = (void*) iov_buffer;
    _args.total_iovlen = total_iovlen;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_sendmsg_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct msghdr));
    if (msg_name) OE_ADD_SIZE(_input_buffer_size, _args.msg_namelen);
    if (msg_iov) OE_ADD_SIZE(_input_buffer_size, (_args.msg_iovlen * sizeof(struct iovec)));
    if (msg_control) OE_ADD_SIZE(_input_buffer_size, _args.msg_controllen);
    if (iov_buffer) OE_ADD_SIZE(_input_buffer_size, _args.total_iovlen);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_sendmsg_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, sizeof(struct msghdr));
    OE_WRITE_IN_PARAM(msg_name, _args.msg_namelen);
    OE_WRITE_IN_PARAM(msg_iov, (_args.msg_iovlen * sizeof(struct iovec)));
    OE_WRITE_IN_PARAM(msg_control, _args.msg_controllen);
    OE_WRITE_IN_PARAM(iov_buffer, _args.total_iovlen);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_sendmsg,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_recvmsg(
        oe_recvmsg_result_t* _retval,
        int a,
        struct msghdr* b,
        int c,
        void* msg_name,
        int msg_namelen,
        int* actual_msg_namelen,
        struct iovec* msg_iov,
        int msg_iovlen,
        int* actual_msg_iovlen,
        void* msg_control,
        int msg_controllen,
        int* actual_msg_controllen,
        int* msg_flags,
        void* individual_iov_buffer,
        int individual_iov_len,
        int* actual_individual_iov_len)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_recvmsg_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct msghdr*) b;
    _args.c = c;
    _args.msg_name = (void*) msg_name;
    _args.msg_namelen = msg_namelen;
    _args.actual_msg_namelen = (int*) actual_msg_namelen;
    _args.msg_iov = (struct iovec*) msg_iov;
    _args.msg_iovlen = msg_iovlen;
    _args.actual_msg_iovlen = (int*) actual_msg_iovlen;
    _args.msg_control = (void*) msg_control;
    _args.msg_controllen = msg_controllen;
    _args.actual_msg_controllen = (int*) actual_msg_controllen;
    _args.msg_flags = (int*) msg_flags;
    _args.individual_iov_buffer = (void*) individual_iov_buffer;
    _args.individual_iov_len = individual_iov_len;
    _args.actual_individual_iov_len = (int*) actual_individual_iov_len;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_recvmsg_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct msghdr));
    if (msg_name) OE_ADD_SIZE(_input_buffer_size, _args.msg_namelen);
    if (actual_msg_namelen) OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (msg_iov) OE_ADD_SIZE(_input_buffer_size, (_args.msg_iovlen * sizeof(struct iovec)));
    if (actual_msg_iovlen) OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (msg_control) OE_ADD_SIZE(_input_buffer_size, _args.msg_controllen);
    if (actual_msg_controllen) OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (msg_flags) OE_ADD_SIZE(_input_buffer_size, sizeof(int));
    if (individual_iov_buffer) OE_ADD_SIZE(_input_buffer_size, _args.individual_iov_len);
    if (actual_individual_iov_len) OE_ADD_SIZE(_input_buffer_size, sizeof(int));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_recvmsg_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(struct msghdr));
    if (actual_msg_namelen) OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (msg_iov) OE_ADD_SIZE(_output_buffer_size, (_args.msg_iovlen * sizeof(struct iovec)));
    if (actual_msg_iovlen) OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (msg_control) OE_ADD_SIZE(_output_buffer_size, _args.msg_controllen);
    if (actual_msg_controllen) OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (msg_flags) OE_ADD_SIZE(_output_buffer_size, sizeof(int));
    if (individual_iov_buffer) OE_ADD_SIZE(_output_buffer_size, _args.individual_iov_len);
    if (actual_individual_iov_len) OE_ADD_SIZE(_output_buffer_size, sizeof(int));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, sizeof(struct msghdr));
    OE_WRITE_IN_PARAM(msg_name, _args.msg_namelen);
    OE_WRITE_IN_OUT_PARAM(actual_msg_namelen, sizeof(int));
    OE_WRITE_IN_OUT_PARAM(msg_iov, (_args.msg_iovlen * sizeof(struct iovec)));
    OE_WRITE_IN_OUT_PARAM(actual_msg_iovlen, sizeof(int));
    OE_WRITE_IN_OUT_PARAM(msg_control, _args.msg_controllen);
    OE_WRITE_IN_OUT_PARAM(actual_msg_controllen, sizeof(int));
    OE_WRITE_IN_OUT_PARAM(msg_flags, sizeof(int));
    OE_WRITE_IN_OUT_PARAM(individual_iov_buffer, _args.individual_iov_len);
    OE_WRITE_IN_OUT_PARAM(actual_individual_iov_len, sizeof(int));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_recvmsg,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(struct msghdr)));
    OE_READ_IN_OUT_PARAM(actual_msg_namelen, (size_t)(sizeof(int)));
    OE_READ_IN_OUT_PARAM(msg_iov, (size_t)((_args.msg_iovlen * sizeof(struct iovec))));
    OE_READ_IN_OUT_PARAM(actual_msg_iovlen, (size_t)(sizeof(int)));
    OE_READ_IN_OUT_PARAM(msg_control, (size_t)(_args.msg_controllen));
    OE_READ_IN_OUT_PARAM(actual_msg_controllen, (size_t)(sizeof(int)));
    OE_READ_IN_OUT_PARAM(msg_flags, (size_t)(sizeof(int)));
    OE_READ_IN_OUT_PARAM(individual_iov_buffer, (size_t)(_args.individual_iov_len));
    OE_READ_IN_OUT_PARAM(actual_individual_iov_len, (size_t)(sizeof(int)));

    _result = OE_OK;
done:    
    //if (_buffer)
    //    oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getsockopt(
        oe_getsockopt_result_t* _retval,
        int a,
        int b,
        int c,
        void* d,
        socklen_t e_,
        socklen_t* e)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getsockopt_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;
    _args.d = (void*) d;
    _args.e_ = e_;
    _args.e = (socklen_t*) e;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getsockopt_args_t));
    if (d) OE_ADD_SIZE(_input_buffer_size, _args.e_);
    if (e) OE_ADD_SIZE(_input_buffer_size, sizeof(socklen_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getsockopt_args_t));
    if (d) OE_ADD_SIZE(_output_buffer_size, _args.e_);
    if (e) OE_ADD_SIZE(_output_buffer_size, sizeof(socklen_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(d, _args.e_);
    OE_WRITE_IN_OUT_PARAM(e, sizeof(socklen_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getsockopt,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(d, (size_t)(_args.e_));
    OE_READ_IN_OUT_PARAM(e, (size_t)(sizeof(socklen_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_setsockopt(
        oe_setsockopt_result_t* _retval,
        int a,
        int b,
        int c,
        const void* d,
        socklen_t e)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_setsockopt_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;
    _args.d = (void*) d;
    _args.e = e;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_setsockopt_args_t));
    if (d) OE_ADD_SIZE(_input_buffer_size, _args.e);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_setsockopt_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(d, _args.e);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_setsockopt,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_listen(
        oe_listen_result_t* _retval,
        int a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_listen_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_listen_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_listen_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_listen,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_accept(
        oe_accept_result_t* _retval,
        int a,
        struct sockaddr* b,
        socklen_t c_,
        socklen_t* c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_accept_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct sockaddr*) b;
    _args.c_ = c_;
    _args.c = (socklen_t*) c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_accept_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(socklen_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_accept_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, _args.c_);
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(socklen_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, _args.c_);
    OE_WRITE_IN_OUT_PARAM(c, sizeof(socklen_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_accept,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(_args.c_));
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(socklen_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_shutdown(
        oe_shutdown_result_t* _retval,
        int a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_shutdown_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_shutdown_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_shutdown_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_shutdown,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_sockatmark(
        oe_sockatmark_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_sockatmark_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_sockatmark_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_sockatmark_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_sockatmark,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_isfdtype(
        oe_isfdtype_result_t* _retval,
        int a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_isfdtype_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_isfdtype_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_isfdtype_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_isfdtype,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_exit(
        int arg)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    host_exit_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.arg = arg;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_exit_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_exit_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_host_exit,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_create_thread(
        uint64_t enc_key,
        oe_enclave_t* enc)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    host_create_thread_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.enc_key = enc_key;
    _args.enc = (oe_enclave_t*) enc;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_create_thread_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_create_thread_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_host_create_thread,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_join_thread(
        int* _retval,
        uint64_t enc_key)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    host_join_thread_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.enc_key = enc_key;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_join_thread_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_join_thread_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_host_join_thread,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_detach_thread(
        int* _retval,
        uint64_t enc_key)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    host_detach_thread_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.enc_key = enc_key;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_detach_thread_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_detach_thread_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_host_detach_thread,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t host_cond_timedwait(
        int* _retval,
        pthread_cond_t* cond,
        pthread_mutex_t* mutex,
        const struct timespec* abstime)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    host_cond_timedwait_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.cond = (pthread_cond_t*) cond;
    _args.mutex = (pthread_mutex_t*) mutex;
    _args.abstime = (struct timespec*) abstime;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(host_cond_timedwait_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(host_cond_timedwait_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_host_cond_timedwait,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_cond_timedwait(
        oe_pthread_cond_timedwait_result_t* _retval,
        pthread_cond_t* a,
        pthread_mutex_t* b,
        const struct timespec* c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_cond_timedwait_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_cond_t*) a;
    _args.b = (pthread_mutex_t*) b;
    _args.c = (struct timespec*) c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_cond_timedwait_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_cond_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_mutex_t));
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(struct timespec));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_cond_timedwait_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_cond_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_mutex_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_cond_t));
    OE_WRITE_IN_OUT_PARAM(b, sizeof(pthread_mutex_t));
    OE_WRITE_IN_PARAM(c, sizeof(struct timespec));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_cond_timedwait,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_cond_t)));
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(pthread_mutex_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_attr_init(
        oe_pthread_attr_init_result_t* _retval,
        pthread_attr_t* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_attr_init_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_attr_t*) a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_attr_init_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_attr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_attr_init_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_attr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_attr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_attr_init,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_attr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_attr_destroy(
        oe_pthread_attr_destroy_result_t* _retval,
        pthread_attr_t* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_attr_destroy_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_attr_t*) a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_attr_destroy_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_attr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_attr_destroy_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_attr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_attr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_attr_destroy,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_attr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_attr_setdetachstate(
        oe_pthread_attr_setdetachstate_result_t* _retval,
        pthread_attr_t* a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_attr_setdetachstate_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_attr_t*) a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_attr_setdetachstate_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_attr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_attr_setdetachstate_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_attr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_attr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_attr_setdetachstate,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_attr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_init(
        oe_pthread_condattr_init_result_t* _retval,
        pthread_condattr_t* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_init_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_init_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_init_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_condattr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_condattr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_init,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_condattr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_destroy(
        oe_pthread_condattr_destroy_result_t* _retval,
        pthread_condattr_t* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_destroy_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_destroy_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_destroy_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_condattr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_condattr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_destroy,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_condattr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_setclock(
        oe_pthread_condattr_setclock_result_t* _retval,
        pthread_condattr_t* a,
        clockid_t b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_setclock_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_setclock_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_setclock_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_condattr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_condattr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_setclock,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_condattr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_setpshared(
        oe_pthread_condattr_setpshared_result_t* _retval,
        pthread_condattr_t* a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_setpshared_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_setpshared_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_setpshared_args_t));
    if (a) OE_ADD_SIZE(_output_buffer_size, sizeof(pthread_condattr_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(a, sizeof(pthread_condattr_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_setpshared,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(a, (size_t)(sizeof(pthread_condattr_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_getclock(
        oe_pthread_condattr_getclock_result_t* _retval,
        const pthread_condattr_t* a,
        clockid_t* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_getclock_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;
    _args.b = (clockid_t*) b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_getclock_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(clockid_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_getclock_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(clockid_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, sizeof(pthread_condattr_t));
    OE_WRITE_IN_OUT_PARAM(b, sizeof(clockid_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_getclock,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(clockid_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_pthread_condattr_getpshared(
        oe_pthread_condattr_getpshared_result_t* _retval,
        const pthread_condattr_t* a,
        int* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_pthread_condattr_getpshared_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (pthread_condattr_t*) a;
    _args.b = (int*) b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_pthread_condattr_getpshared_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, sizeof(pthread_condattr_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(int));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_pthread_condattr_getpshared_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(int));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, sizeof(pthread_condattr_t));
    OE_WRITE_IN_OUT_PARAM(b, sizeof(int));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_pthread_condattr_getpshared,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(int)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_eventfd(
        oe_eventfd_result_t* _retval,
        unsigned int a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_eventfd_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_eventfd_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_eventfd_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_eventfd,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_eventfd_read(
        oe_eventfd_read_result_t* _retval,
        int a,
        eventfd_t* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_eventfd_read_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (eventfd_t*) b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_eventfd_read_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(eventfd_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_eventfd_read_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(eventfd_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, sizeof(eventfd_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_eventfd_read,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(eventfd_t)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_eventfd_write(
        oe_eventfd_write_result_t* _retval,
        int a,
        eventfd_t b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_eventfd_write_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_eventfd_write_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_eventfd_write_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_eventfd_write,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_htonl(
        oe_htonl_result_t* _retval,
        uint32_t a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_htonl_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_htonl_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_htonl_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_htonl,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_htons(
        oe_htons_result_t* _retval,
        uint16_t a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_htons_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_htons_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_htons_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_htons,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_ntohl(
        oe_ntohl_result_t* _retval,
        uint32_t a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_ntohl_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_ntohl_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_ntohl_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_ntohl,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_ntohs(
        oe_ntohs_result_t* _retval,
        uint16_t a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_ntohs_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_ntohs_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_ntohs_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_ntohs,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_addr(
        oe_inet_addr_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_addr_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_addr_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_addr_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_addr,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_network(
        oe_inet_network_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_network_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_network_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_network_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_network,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_ntoa(
        oe_inet_ntoa_result_t* _retval,
        struct in_addr a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_ntoa_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_ntoa_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_ntoa_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_ntoa,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_pton(
        oe_inet_pton_result_t* _retval,
        int a,
        const char* b,
        void* c,
        int d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_pton_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;
    _args.c = (void*) c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_pton_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));
    if (c) OE_ADD_SIZE(_input_buffer_size, _args.d);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_pton_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, _args.d);

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(c, _args.d);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_pton,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(_args.d));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_ntop(
        oe_inet_ntop_result_t* _retval,
        int a,
        const void* b,
        int e,
        char* c,
        socklen_t d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_ntop_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (void*) b;
    _args.e = e;
    _args.c = (char*) c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_ntop_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.e);
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_ntop_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(char));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.e);
    OE_WRITE_IN_OUT_PARAM(c, sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_ntop,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(char)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_aton(
        oe_inet_aton_result_t* _retval,
        const char* a,
        struct in_addr* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_aton_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = (struct in_addr*) b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_aton_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct in_addr));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_aton_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(struct in_addr));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(b, sizeof(struct in_addr));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_aton,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(struct in_addr)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_makeaddr(
        oe_inet_makeaddr_result_t* _retval,
        in_addr_t a,
        in_addr_t b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_makeaddr_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_makeaddr_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_makeaddr_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_makeaddr,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_lnaof(
        oe_inet_lnaof_result_t* _retval,
        struct in_addr a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_lnaof_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_lnaof_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_lnaof_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_lnaof,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_inet_netof(
        oe_inet_netof_result_t* _retval,
        struct in_addr a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_inet_netof_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_inet_netof_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_inet_netof_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_inet_netof,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getaddrinfo(
        oe_getaddrinfo_result_t* _retval,
        const char* a,
        const char* b,
        const struct addrinfo* c,
        struct addrinfo** d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getaddrinfo_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;
    _args.c = (struct addrinfo*) c;
    _args.d = (struct addrinfo**) d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getaddrinfo_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(struct addrinfo));
    if (d) OE_ADD_SIZE(_input_buffer_size, sizeof(struct addrinfo*));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getaddrinfo_args_t));
    if (d) OE_ADD_SIZE(_output_buffer_size, sizeof(struct addrinfo*));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));
    OE_WRITE_IN_PARAM(c, sizeof(struct addrinfo));
    OE_WRITE_IN_OUT_PARAM(d, sizeof(struct addrinfo*));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getaddrinfo,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(d, (size_t)(sizeof(struct addrinfo*)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_freeaddrinfo(
        oe_freeaddrinfo_result_t* _retval,
        struct addrinfo* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_freeaddrinfo_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (struct addrinfo*) a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_freeaddrinfo_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_freeaddrinfo_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_freeaddrinfo,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getnameinfo(
        oe_getnameinfo_result_t* _retval,
        const struct sockaddr* a,
        socklen_t b,
        char* c,
        socklen_t d,
        char* e,
        socklen_t f,
        int g)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getnameinfo_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (struct sockaddr*) a;
    _args.b = b;
    _args.c = (char*) c;
    _args.d = d;
    _args.e = (char*) e;
    _args.f = f;
    _args.g = g;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getnameinfo_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.b);
    if (c) OE_ADD_SIZE(_input_buffer_size, _args.d);
    if (e) OE_ADD_SIZE(_input_buffer_size, _args.f);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getnameinfo_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, _args.d);
    if (e) OE_ADD_SIZE(_output_buffer_size, _args.f);

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.b);
    OE_WRITE_IN_OUT_PARAM(c, _args.d);
    OE_WRITE_IN_OUT_PARAM(e, _args.f);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getnameinfo,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(_args.d));
    OE_READ_IN_OUT_PARAM(e, (size_t)(_args.f));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gai_strerror(
        oe_gai_strerror_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gai_strerror_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gai_strerror_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gai_strerror_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gai_strerror,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_sethostent(
        oe_sethostent_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_sethostent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_sethostent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_sethostent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_sethostent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_endhostent(
        oe_endhostent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_endhostent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_endhostent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_endhostent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_endhostent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostent(
        oe_gethostent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_setnetent(
        oe_setnetent_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_setnetent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_setnetent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_setnetent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_setnetent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_endnetent(
        oe_endnetent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_endnetent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_endnetent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_endnetent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_endnetent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getnetent(
        oe_getnetent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getnetent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getnetent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getnetent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getnetent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getnetbyaddr(
        oe_getnetbyaddr_result_t* _retval,
        uint32_t a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getnetbyaddr_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getnetbyaddr_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getnetbyaddr_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getnetbyaddr,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getnetbyname(
        oe_getnetbyname_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getnetbyname_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getnetbyname_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getnetbyname_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getnetbyname,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_setservent(
        oe_setservent_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_setservent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_setservent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_setservent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_setservent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_endservent(
        oe_endservent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_endservent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_endservent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_endservent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_endservent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getservent(
        oe_getservent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getservent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getservent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getservent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getservent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getservbyname(
        oe_getservbyname_result_t* _retval,
        const char* a,
        const char* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getservbyname_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getservbyname_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getservbyname_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getservbyname,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getservbyport(
        oe_getservbyport_result_t* _retval,
        int a,
        const char* b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getservbyport_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getservbyport_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getservbyport_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getservbyport,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_setprotoent(
        oe_setprotoent_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_setprotoent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_setprotoent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_setprotoent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_setprotoent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_endprotoent(
        oe_endprotoent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_endprotoent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_endprotoent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_endprotoent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_endprotoent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getprotoent(
        oe_getprotoent_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getprotoent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getprotoent_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getprotoent_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getprotoent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getprotobyname(
        oe_getprotobyname_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getprotobyname_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getprotobyname_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getprotobyname_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getprotobyname,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getprotobynumber(
        oe_getprotobynumber_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getprotobynumber_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getprotobynumber_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getprotobynumber_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getprotobynumber,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyname(
        oe_gethostbyname_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyname_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyname_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyname_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyname,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyaddr(
        oe_gethostbyaddr_result_t* _retval,
        const void* a,
        socklen_t b,
        int c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyaddr_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (void*) a;
    _args.b = b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyaddr_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.b);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyaddr_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.b);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyaddr,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall___h_errno_location(
        oe___h_errno_location_result_t* _retval)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall___h_errno_location_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall___h_errno_location_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall___h_errno_location_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall___h_errno_location,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_herror(
        oe_herror_result_t* _retval,
        const char* a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_herror_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_herror_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_herror_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_herror,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_hstrerror(
        oe_hstrerror_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_hstrerror_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_hstrerror_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_hstrerror_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_hstrerror,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyname_r(
        oe_gethostbyname_r_result_t* _retval,
        const char* a,
        struct hostent* b,
        char* c,
        size_t d,
        struct hostent** e,
        int* f)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyname_r_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = (struct hostent*) b;
    _args.c = (char*) c;
    _args.d = d;
    _args.e = (struct hostent**) e;
    _args.f = (int*) f;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyname_r_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent));
    if (c) OE_ADD_SIZE(_input_buffer_size, _args.d);
    if (e) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent*));
    if (f) OE_ADD_SIZE(_input_buffer_size, sizeof(int));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyname_r_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent));
    if (c) OE_ADD_SIZE(_output_buffer_size, _args.d);
    if (e) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent*));
    if (f) OE_ADD_SIZE(_output_buffer_size, sizeof(int));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(b, sizeof(struct hostent));
    OE_WRITE_IN_OUT_PARAM(c, _args.d);
    OE_WRITE_IN_OUT_PARAM(e, sizeof(struct hostent*));
    OE_WRITE_IN_OUT_PARAM(f, sizeof(int));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyname_r,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(struct hostent)));
    OE_READ_IN_OUT_PARAM(c, (size_t)(_args.d));
    OE_READ_IN_OUT_PARAM(e, (size_t)(sizeof(struct hostent*)));
    OE_READ_IN_OUT_PARAM(f, (size_t)(sizeof(int)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyname2_r(
        oe_gethostbyname2_r_result_t* _retval,
        const char* a,
        int b,
        struct hostent* c,
        char* d,
        size_t e,
        struct hostent** f,
        int* g)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyname2_r_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = b;
    _args.c = (struct hostent*) c;
    _args.d = (char*) d;
    _args.e = e;
    _args.f = (struct hostent**) f;
    _args.g = (int*) g;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyname2_r_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent));
    if (d) OE_ADD_SIZE(_input_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent*));
    if (g) OE_ADD_SIZE(_input_buffer_size, sizeof(int));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyname2_r_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent));
    if (d) OE_ADD_SIZE(_output_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent*));
    if (g) OE_ADD_SIZE(_output_buffer_size, sizeof(int));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(c, sizeof(struct hostent));
    OE_WRITE_IN_OUT_PARAM(d, _args.e);
    OE_WRITE_IN_OUT_PARAM(f, sizeof(struct hostent*));
    OE_WRITE_IN_OUT_PARAM(g, sizeof(int));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyname2_r,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(struct hostent)));
    OE_READ_IN_OUT_PARAM(d, (size_t)(_args.e));
    OE_READ_IN_OUT_PARAM(f, (size_t)(sizeof(struct hostent*)));
    OE_READ_IN_OUT_PARAM(g, (size_t)(sizeof(int)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyname2(
        oe_gethostbyname2_result_t* _retval,
        const char* a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyname2_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyname2_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyname2_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyname2,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_gethostbyaddr_r(
        oe_gethostbyaddr_r_result_t* _retval,
        const void* a,
        socklen_t b,
        int c,
        struct hostent* d,
        char* e,
        size_t f,
        struct hostent** g,
        int* h)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_gethostbyaddr_r_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (void*) a;
    _args.b = b;
    _args.c = c;
    _args.d = (struct hostent*) d;
    _args.e = (char*) e;
    _args.f = f;
    _args.g = (struct hostent**) g;
    _args.h = (int*) h;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_gethostbyaddr_r_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.b);
    if (d) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent));
    if (e) OE_ADD_SIZE(_input_buffer_size, _args.f);
    if (g) OE_ADD_SIZE(_input_buffer_size, sizeof(struct hostent*));
    if (h) OE_ADD_SIZE(_input_buffer_size, sizeof(int));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_gethostbyaddr_r_args_t));
    if (d) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent));
    if (e) OE_ADD_SIZE(_output_buffer_size, _args.f);
    if (g) OE_ADD_SIZE(_output_buffer_size, sizeof(struct hostent*));
    if (h) OE_ADD_SIZE(_output_buffer_size, sizeof(int));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.b);
    OE_WRITE_IN_OUT_PARAM(d, sizeof(struct hostent));
    OE_WRITE_IN_OUT_PARAM(e, _args.f);
    OE_WRITE_IN_OUT_PARAM(g, sizeof(struct hostent*));
    OE_WRITE_IN_OUT_PARAM(h, sizeof(int));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_gethostbyaddr_r,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(d, (size_t)(sizeof(struct hostent)));
    OE_READ_IN_OUT_PARAM(e, (size_t)(_args.f));
    OE_READ_IN_OUT_PARAM(g, (size_t)(sizeof(struct hostent*)));
    OE_READ_IN_OUT_PARAM(h, (size_t)(sizeof(int)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getservbyport_r(
        oe_getservbyport_r_result_t* _retval,
        int a,
        const char* b,
        struct servent* c,
        char* d,
        size_t e,
        struct servent** f)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getservbyport_r_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;
    _args.c = (struct servent*) c;
    _args.d = (char*) d;
    _args.e = e;
    _args.f = (struct servent**) f;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getservbyport_r_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(struct servent));
    if (d) OE_ADD_SIZE(_input_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_input_buffer_size, sizeof(struct servent*));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getservbyport_r_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(struct servent));
    if (d) OE_ADD_SIZE(_output_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_output_buffer_size, sizeof(struct servent*));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(c, sizeof(struct servent));
    OE_WRITE_IN_OUT_PARAM(d, _args.e);
    OE_WRITE_IN_OUT_PARAM(f, sizeof(struct servent*));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getservbyport_r,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(struct servent)));
    OE_READ_IN_OUT_PARAM(d, (size_t)(_args.e));
    OE_READ_IN_OUT_PARAM(f, (size_t)(sizeof(struct servent*)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_getservbyname_r(
        oe_getservbyname_r_result_t* _retval,
        const char* a,
        const char* b,
        struct servent* c,
        char* d,
        size_t e,
        struct servent** f)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_getservbyname_r_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;
    _args.c = (struct servent*) c;
    _args.d = (char*) d;
    _args.e = e;
    _args.f = (struct servent**) f;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_getservbyname_r_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));
    if (c) OE_ADD_SIZE(_input_buffer_size, sizeof(struct servent));
    if (d) OE_ADD_SIZE(_input_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_input_buffer_size, sizeof(struct servent*));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_getservbyname_r_args_t));
    if (c) OE_ADD_SIZE(_output_buffer_size, sizeof(struct servent));
    if (d) OE_ADD_SIZE(_output_buffer_size, _args.e);
    if (f) OE_ADD_SIZE(_output_buffer_size, sizeof(struct servent*));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));
    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));
    OE_WRITE_IN_OUT_PARAM(c, sizeof(struct servent));
    OE_WRITE_IN_OUT_PARAM(d, _args.e);
    OE_WRITE_IN_OUT_PARAM(f, sizeof(struct servent*));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_getservbyname_r,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(c, (size_t)(sizeof(struct servent)));
    OE_READ_IN_OUT_PARAM(d, (size_t)(_args.e));
    OE_READ_IN_OUT_PARAM(f, (size_t)(sizeof(struct servent*)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_epoll_create(
        oe_epoll_create_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_epoll_create_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_epoll_create_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_epoll_create_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_epoll_create,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_epoll_create1(
        oe_epoll_create1_result_t* _retval,
        int a)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_epoll_create1_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_epoll_create1_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_epoll_create1_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_epoll_create1,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_epoll_ctl(
        oe_epoll_ctl_result_t* _retval,
        int a,
        int b,
        int c,
        struct epoll_event* d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_epoll_ctl_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;
    _args.d = (struct epoll_event*) d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_epoll_ctl_args_t));
    if (d) OE_ADD_SIZE(_input_buffer_size, sizeof(struct epoll_event));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_epoll_ctl_args_t));
    if (d) OE_ADD_SIZE(_output_buffer_size, sizeof(struct epoll_event));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(d, sizeof(struct epoll_event));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_epoll_ctl,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(d, (size_t)(sizeof(struct epoll_event)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_epoll_wait(
        oe_epoll_wait_result_t* _retval,
        int a,
        struct epoll_event* b,
        int c,
        int d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_epoll_wait_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct epoll_event*) b;
    _args.c = c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_epoll_wait_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct epoll_event));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_epoll_wait_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(struct epoll_event));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, sizeof(struct epoll_event));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_epoll_wait,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(struct epoll_event)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_epoll_pwait(
        oe_epoll_pwait_result_t* _retval,
        int a,
        struct epoll_event* b,
        int c,
        int d,
        const sigset_t* e)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_epoll_pwait_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (struct epoll_event*) b;
    _args.c = c;
    _args.d = d;
    _args.e = (sigset_t*) e;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_epoll_pwait_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, sizeof(struct epoll_event));
    if (e) OE_ADD_SIZE(_input_buffer_size, sizeof(sigset_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_epoll_pwait_args_t));
    if (b) OE_ADD_SIZE(_output_buffer_size, sizeof(struct epoll_event));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_OUT_PARAM(b, sizeof(struct epoll_event));
    OE_WRITE_IN_PARAM(e, sizeof(sigset_t));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_epoll_pwait,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(struct epoll_event)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_creat(
        oe_creat_result_t* _retval,
        const char* a,
        mode_t b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_creat_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_creat_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_creat_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_creat,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_fcntl(
        oe_fcntl_result_t* _retval,
        int a,
        int b,
        int64_t c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_fcntl_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_fcntl_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_fcntl_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_fcntl,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_open(
        oe_open_result_t* _retval,
        const char* a,
        int b)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_open_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = (char*) a;
    _args.a_len = (a) ? (strlen(a) + 1) : 0;
    _args.b = b;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_open_args_t));
    if (a) OE_ADD_SIZE(_input_buffer_size, _args.a_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_open_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(a, _args.a_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_open,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_openat(
        oe_openat_result_t* _retval,
        int a,
        const char* b,
        int c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_openat_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = (char*) b;
    _args.b_len = (b) ? (strlen(b) + 1) : 0;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_openat_args_t));
    if (b) OE_ADD_SIZE(_input_buffer_size, _args.b_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_openat_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(b, _args.b_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_openat,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_posix_fadvise(
        oe_posix_fadvise_result_t* _retval,
        int a,
        off_t b,
        off_t c,
        int d)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_posix_fadvise_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;
    _args.d = d;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_posix_fadvise_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_posix_fadvise_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_posix_fadvise,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_posix_fallocate(
        oe_posix_fallocate_result_t* _retval,
        int a,
        off_t b,
        off_t c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_posix_fallocate_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_posix_fallocate_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_posix_fallocate_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_posix_fallocate,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_host_ocall_lockf(
        oe_lockf_result_t* _retval,
        int a,
        int b,
        off_t c)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct */ 
    oe_host_ocall_lockf_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshalling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct */
    memset(&_args, 0, sizeof(_args));
    _args.a = a;
    _args.b = b;
    _args.c = c;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_host_ocall_lockf_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_host_ocall_lockf_args_t));

    /* Allocate marshalling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_oe_host_ocall_lockf,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer */
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

OE_EXTERNC_END
